import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface Home {
  city: string;
  region: string;
  country: string;
}

interface RegisteredState {
  region: string;
  country: string;
  firstCity?: string;
}

interface RegisteredData {
  states?: RegisteredState[];
  [key: string]: unknown;
}

interface StatePlace {
  region: string;
  country: string;
  firstCity?: string;
}

interface StatePlaceWithKey extends StatePlace {
  key: string;
}

interface PlacesOutput {
  updatedAt: string;
  home: Home;
  count: number;
  places: StatePlaceWithKey[];
}

/**
 * Normalize whitespace: trim and collapse internal whitespace
 */
function normalizeWhitespace(str: string): string {
  return str.trim().replace(/\s+/g, ' ');
}

/**
 * Normalize a state place by trimming whitespace and creating a dedupe key
 */
function normalizeState(state: RegisteredState): { normalized: StatePlace; key: string } {
  const normalized: StatePlace = {
    region: normalizeWhitespace(state.region),
    country: normalizeWhitespace(state.country),
    firstCity: state.firstCity ? normalizeWhitespace(state.firstCity) : undefined,
  };

  // Create stable dedupe key using lowercase: region|country
  const key = `${normalized.region.toLowerCase()}|${normalized.country.toLowerCase()}`;

  return { normalized, key };
}

/**
 * Sort places by country, then region (case-insensitive)
 */
function sortPlaces(places: StatePlaceWithKey[]): StatePlaceWithKey[] {
  return [...places].sort((a, b) => {
    const countryCompare = a.country.toLowerCase().localeCompare(b.country.toLowerCase());
    if (countryCompare !== 0) return countryCompare;

    return a.region.toLowerCase().localeCompare(b.region.toLowerCase());
  });
}

function main() {
  const projectRoot = join(__dirname, '../..');
  const registeredPath = join(projectRoot, 'data/places/registered.json');
  const homePath = join(projectRoot, 'data/places/home.json');
  const outputPath = join(projectRoot, 'api/places.json');

  // Read home data
  let home: Home;
  try {
    const homeContent = readFileSync(homePath, 'utf-8');
    home = JSON.parse(homeContent) as Home;
    // Normalize home fields
    home = {
      city: normalizeWhitespace(home.city),
      region: normalizeWhitespace(home.region),
      country: normalizeWhitespace(home.country),
    };
  } catch (error) {
    console.error(`Failed to read ${homePath}:`, error);
    process.exit(1);
  }

  // Read registered states data
  let registeredData: RegisteredData;
  try {
    const registeredContent = readFileSync(registeredPath, 'utf-8');
    registeredData = JSON.parse(registeredContent) as RegisteredData;
  } catch (error) {
    console.error(`Failed to read ${registeredPath}:`, error);
    console.error('This file is generated by the GitHub Action workflow.');
    console.error('To generate it locally, run the GitHub Action or create the file manually.');
    process.exit(1);
  }

  // Extract states array (handle different possible structures)
  const states: RegisteredState[] = Array.isArray(registeredData.states)
    ? registeredData.states
    : Array.isArray(registeredData)
    ? registeredData
    : [];

  if (states.length === 0) {
    console.warn('Warning: No states found in registered.json');
  }

  // Normalize and dedupe places by state (region|country)
  const seenKeys = new Set<string>();
  const placesWithKeys: StatePlaceWithKey[] = [];

  for (const state of states) {
    if (!state.region || !state.country) {
      console.warn('Skipping invalid state entry:', state);
      continue;
    }

    const { normalized, key } = normalizeState(state);

    // If state already seen, skip (defensive deduplication)
    if (seenKeys.has(key)) {
      continue;
    }

    seenKeys.add(key);
    placesWithKeys.push({
      ...normalized,
      key,
    });
  }

  // Sort places by country then region
  const sortedPlaces = sortPlaces(placesWithKeys);

  // Build output object
  const output: PlacesOutput = {
    updatedAt: new Date().toISOString(),
    home,
    count: sortedPlaces.length,
    places: sortedPlaces,
  };

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  try {
    mkdirSync(outputDir, { recursive: true });
  } catch (error) {
    // Directory might already exist, that's okay
  }

  // Write output file with 2-space indentation and trailing newline
  const outputJson = JSON.stringify(output, null, 2) + '\n';
  writeFileSync(outputPath, outputJson, 'utf-8');

  console.log(`Successfully generated ${outputPath}`);
  console.log(JSON.stringify(output, null, 2));
}

main();
